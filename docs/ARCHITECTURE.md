# Архитектура Онлайн-Кинотеатра

## Обзор системы
Система построена по микросервисной архитектуре с четким разделением ответственности.

## Компоненты системы

### 1. API Gateway
**Роль**: Единая точка входа в систему
**Взаимодействие**:
- Принимает все входящие HTTP запросы
- Маршрутизирует запросы к соответствующим сервисам
- Обрабатывает аутентификацию и авторизацию
- Реализует rate limiting

### 2. User Service
**Роль**: Управление пользователями
**Взаимодействие**:
- Хранит данные пользователей в PostgreSQL
- Генерирует JWT токены
- Аутентифицирует запросы через API Gateway

### 3. Catalog Service
**Роль**: Управление каталогом фильмов
**Взаимодействие**:
- Хранит метаданные фильмов в PostgreSQL
- Отправляет данные в Search Service через Kafka
- Получает запросы от API Gateway

### 4. Search Service
**Роль**: Поиск по фильмам
**Взаимодействие**:
- Индексирует данные из Catalog Service в Elasticsearch
- Обслуживает поисковые запросы
- Предоставляет автодополнение

### 5. Streaming Service
**Роль**: Потоковая передача видео
**Взаимодействие**:
- Хранит медиафайлы в S3/MinIO
- Преобразует видео в HLS/DASH форматы
- Отслеживает прогресс просмотра и отправляет в Analytics Service

### 6. Analytics Service
**Роль**: Сбор и анализ данных
**Взаимодействие**:
- Получает события пользовательской активности через Kafka
- Хранит данные в ClickHouse для аналитики
- Предоставляет данные для дашбордов

### 7. ETL Service
**Роль**: Загрузка и обработка данных
**Взаимодействие**:
- Загружает данные о фильмах из внешних источников
- Очищает и преобразует данные
- Загружает в Catalog Service и Search Service

### 8. Notification Service
**Роль**: Уведомления пользователей
**Взаимодействие**:
- Получает события через Kafka
- Отправляет email/push уведомления
- Интегрируется с User Service для получения контактов

## Способы взаимодействия

### 1. Синхронное HTTP (REST)
- API Gateway ↔ Все сервисы
- Внешние клиенты ↔ API Gateway

### 2. Асинхронное (Kafka)
- Catalog Service → Search Service (индексация фильмов)
- Streaming Service → Analytics Service (события просмотра)
- Все сервисы → Notification Service (уведомления)

### 3. Базы данных
- PostgreSQL: User Service, Catalog Service
- Elasticsearch: Search Service
- ClickHouse: Analytics Service
- Redis: Кэширование, сессии

## Обоснование выбора архитектуры

### Почему микросервисы?
1. **Масштабируемость**: Каждый сервис можно масштабировать независимо
2. **Отказоустойчивость**: Падение одного сервиса не приводит к падению всей системы
3. **Технологическая гибкость**: Можно использовать разные технологии для разных задач

### Почему Kafka для асинхронной коммуникации?
1. **Надежность**: Гарантированная доставка сообщений
2. **Масштабируемость**: Можно обрабатывать миллионы событий в день
3. **Отказоустойчивость**: Сохранение сообщений при падении сервисов

### Почему несколько типов БД?
1. **PostgreSQL** для ACID-транзакций (пользователи, заказы)
2. **Elasticsearch** для полнотекстового поиска
3. **ClickHouse** для аналитики больших данных
4. **Redis** для быстрого кэширования

## Поток данных

1. Пользователь делает запрос через API Gateway
2. API Gateway проверяет аутентификацию через User Service
3. Запрос маршрутизируется к соответствующему сервису
4. Сервис обрабатывает запрос и возвращает ответ
5. События активности отправляются в Kafka
6. Analytics Service обрабатывает события для аналитики
7. Notification Service отправляет уведомления при необходимости

## Масштабирование

### Вертикальное:
- Увеличение ресурсов для отдельных сервисов

### Горизонтальное:
- Репликация сервисов за балансировщиком нагрузки
- Шардирование баз данных
- Кластеризация Kafka и Redis